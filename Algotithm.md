# Algorithm 종류

## 1. Greedy
- 현재상황에서 지금 당장 좋은 것만 고르는 방법
- 대부분의 그리디 알고리즘 문제에서는 문제 해결을 위한 최소한의 아이디어로 문제를 해결한다.


## 2. DFS/BFS
    Node      (0)
              | |
    Edge     7   5
            |     |
    Node   (1)   (2)

- 인접 행렬(Adjacency Matrix)  
graph = [  
    [0, 7, 5],  
    [7, 0, INF],  
    [5, INF, 0]  
]

- 인접 리스트(Adjacency List)  
graph = [[(1,7),(2,5)],[(0,7)],[(0,5)]]

### - DFS(Depth First Search)
깊이 우선 탐색 - 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
1. 탐색 시작 노드를 스택에 저장하고 접근 처리를 한다.
2. 스택의 최상단 노드에 접근하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면, 가장 깊은 곳까지 접근한 것으로 판단하여 스택에 저장되어 있는 최상단 노드를 꺼낸다.
3. 2번 과정을 더 이상 수행 할 수 없을 때까지 반복한다.

### - BFS(Breath First Search)
너비 우선 탐색 - 가까운 노드부터 탐색하는 알고리즘
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리한다.
3. 2번 과정을 더 이상 수행 할 수 없을 때까지 반복한다.

## 3. Sort
list.sort(), Sorted(list l) 함수를 활용한다.

### 선택정렬

### 삽입정렬

### 퀵정렬
기준데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다.

### 병합정렬

### 계수정렬




## 4. BST (Binary Search Tree)


  
## 5. DP (Dynamic Programming)


  
## 6. SP (Short Path)


  
## 7. Graph


  

참고: 이것이 코딩테스트다 with Python

